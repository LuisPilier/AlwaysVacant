var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a;
var ts = require("typescript");
var Lint = require("tslint");
var tsutils = require("tsutils");
var path_1 = require("path");
var OPTION_PREFIX = "prefix";
var OPTION_PREFIX_MAPPED = "prefix-mapped-to";
var OPTION_BASE_URL = "base-url";
var FAILURE_BODY_RELATIVE = "module is being loaded from a relative path. Please use a remapped path. See: https://docs.nativescript.org/angular/code-sharing/intro#remapped-imports.";
var FAILURE_BODY_INSIDE = "module path should not contain reference to current or parent directory inside. Please use a remapped path. See: https://docs.nativescript.org/angular/code-sharing/intro#remapped-imports.";
// Looks for path separator `/` or `\\`(Windows style)
// followed than one or two dot characters
// followed by path separator (same as initial).
var illegalInsideRegex = /(\/|\\)\.\.?\1/;
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        var remapOptions = this.parseRuleOptions(this.ruleArguments);
        var walkerOptions = {
            platformRemapFn: remapOptions ? createRemapFn(sourceFile, remapOptions) : undefined
        };
        return this.applyWithFunction(sourceFile, walk, walkerOptions);
    };
    Rule.prototype.applyWithProgram = function (sourceFile, program) {
        var remapOptions = parseCompilerOptions(program.getCompilerOptions());
        var walkerOptions = {
            platformRemapFn: remapOptions ? createRemapFn(sourceFile, remapOptions) : undefined
        };
        return this.applyWithFunction(sourceFile, walk, walkerOptions);
    };
    Rule.prototype.parseRuleOptions = function (ruleArgs) {
        if (!(ruleArgs &&
            ruleArgs[0] &&
            ruleArgs[0][OPTION_PREFIX] &&
            ruleArgs[0][OPTION_PREFIX_MAPPED] &&
            ruleArgs[0][OPTION_BASE_URL])) {
            return undefined;
        }
        return {
            prefix: ruleArgs[0][OPTION_PREFIX],
            prefixMappedTo: ruleArgs[0][OPTION_PREFIX_MAPPED],
            baseUrl: ruleArgs[0][OPTION_BASE_URL]
        };
    };
    Rule.metadata = {
        ruleName: "prefer-mapped-imports",
        type: "maintainability",
        description: "Prefer using mapped paths when importing external modules or ES6 import declarations.",
        options: {
            type: "object",
            properties: (_a = {},
                _a[OPTION_PREFIX] = { type: "string" },
                _a[OPTION_PREFIX_MAPPED] = { type: "string" },
                _a[OPTION_BASE_URL] = { type: "string" },
                _a)
        },
        // TODO: Add documentation for the recommended remapped paths and link it in the rationale.
        optionsDescription: Lint.Utils.dedent(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n            `", "` specifies the prefix for the mapped imports (usually \"@src/\").\n            `", "` specifies folder that is mapped to the prefix (usually \"src/\").\n            `", "` specifies the base url of the typescript program (usually \".\")"], ["\n            \\`", "\\` specifies the prefix for the mapped imports (usually \"@src/\").\n            \\`", "\\` specifies folder that is mapped to the prefix (usually \"src/\").\n            \\`", "\\` specifies the base url of the typescript program (usually \".\")"])), OPTION_PREFIX, OPTION_PREFIX_MAPPED, OPTION_BASE_URL),
        typescriptOnly: false,
        rationale: "..."
    };
    return Rule;
}(Lint.Rules.OptionallyTypedRule));
exports.Rule = Rule;
function parseCompilerOptions(compilerOptions) {
    if (!compilerOptions || !compilerOptions.baseUrl || !compilerOptions.paths) {
        return undefined;
    }
    var baseUrl = compilerOptions.baseUrl;
    if (!baseUrl.endsWith("/")) {
        baseUrl = baseUrl + "/";
    }
    var paths = compilerOptions.paths;
    var entries = Object.entries(paths);
    var isMobileMapping = function (path) { return ["tns", "android", "ios"].some(function (platform) { return path.includes(platform); }); };
    var isWebMapping = function (path) { return path.includes("web"); };
    var platformEntry = entries.find(function (entry) {
        // entry[0] -> @src/*
        // entry[1] -> [src/*.web, src/*]
        return entry[1].some(function (platform) { return isMobileMapping(platform) || isWebMapping(platform); });
    });
    if (!platformEntry) {
        // `Platform mapping is not found in the configured TS paths!`
        return undefined;
    }
    var prefix = platformEntry[0].substr(0, platformEntry[0].indexOf("*"));
    var prefixMappedTo = platformEntry[1][0].substr(0, platformEntry[1][0].indexOf("*"));
    return {
        baseUrl: baseUrl,
        prefix: prefix,
        prefixMappedTo: prefixMappedTo
    };
}
exports.parseCompilerOptions = parseCompilerOptions;
function walk(ctx) {
    var platformRemapFn = ctx.options.platformRemapFn;
    function getValidationErrorBody(expression) {
        if (tsutils.isStringLiteral(expression)) {
            var path = expression.text;
            // when no siblings allowed path cannot start with '.' (relative)
            if (path[0] === ".") {
                return FAILURE_BODY_RELATIVE;
            }
            // '/../' and '/./' are always disallowed in the middle of module path
            if (illegalInsideRegex.test(path)) {
                return FAILURE_BODY_INSIDE;
            }
        }
        // explicitly return undefined when path is valid or not a literal
        return undefined;
    }
    function cb(node) {
        if (tsutils.isExternalModuleReference(node)) {
            var errorBody = getValidationErrorBody(node.expression);
            if (errorBody !== undefined) {
                if (!platformRemapFn) {
                    ctx.addFailureAt(node.getStart(), node.getWidth(), "External " + errorBody + ": " + node.getText());
                }
                else {
                    // TODO: Create fix
                }
            }
        }
        else if (tsutils.isImportDeclaration(node)) {
            var errorBody = getValidationErrorBody(node.moduleSpecifier);
            if (errorBody !== undefined) {
                if (!platformRemapFn) {
                    ctx.addFailureAt(node.getStart(), node.getWidth(), "Imported " + errorBody + ": " + node.getText());
                }
                else {
                    // Create a fix
                    var moduleSpecifier = node.moduleSpecifier;
                    var importText = moduleSpecifier.getText().substr(1, moduleSpecifier.getText().length - 2);
                    var remappedImport = "'" + platformRemapFn(importText) + "'";
                    var fix = new Lint.Replacement(moduleSpecifier.getStart(), moduleSpecifier.getWidth(), remappedImport);
                    ctx.addFailureAt(node.getStart(), node.getWidth(), "Imported " + errorBody + ": " + node.getText(), fix);
                }
            }
        }
        return ts.forEachChild(node, cb);
    }
    return ts.forEachChild(ctx.sourceFile, cb);
}
function createRemapFn(sourceFile, opts) {
    var fileFolder = path_1.dirname(sourceFile.fileName);
    var basePath = path_1.join(opts.baseUrl, opts.prefixMappedTo);
    return function (relativeImportPath) {
        var absPathToImport = path_1.join(fileFolder, relativeImportPath);
        var remappedImport = absPathToImport.replace(basePath, opts.prefix);
        var normalizedImport = convertWindowsToPosixPath(remappedImport);
        return normalizedImport;
    };
}
function convertWindowsToPosixPath(modulePath) {
    return modulePath.replace(/\\/g, "/");
}
var templateObject_1;
//# sourceMappingURL=preferMappedImportsRule.js.map