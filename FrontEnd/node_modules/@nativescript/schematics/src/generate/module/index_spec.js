"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const testing_1 = require("@angular-devkit/schematics/testing");
const test_1 = require("@schematics/angular/utility/test");
const utils_1 = require("../../utils");
const test_utils_1 = require("../../test-utils");
const utils_2 = require("../utils");
describe('Module Schematic', () => {
    const name = 'foo';
    const project = 'test';
    const moduleClassName = utils_1.toNgModuleClassName(name);
    const defaultOptions = {
        project,
        name,
    };
    const schematicRunner = new testing_1.SchematicTestRunner('@nativescript/schematics', path_1.join(__dirname, '../../collection.json'));
    const getModulePath = (extension) => `/src/app/${name}/${name}.module${extension}.ts`;
    const noExtensionModulePath = getModulePath('');
    const nsModulePath = getModulePath(utils_2.DEFAULT_SHARED_EXTENSIONS.ns);
    const webModulePath = getModulePath(utils_2.DEFAULT_SHARED_EXTENSIONS.web);
    const commonFilePath = `/src/app/${name}/${name}.common.ts`;
    const getRoutingModulePath = (extension) => `/src/app/${name}/${name}-routing.module${extension}.ts`;
    const noExtensionRoutingModulePath = getRoutingModulePath('');
    const nsRoutingModulePath = getRoutingModulePath(utils_2.DEFAULT_SHARED_EXTENSIONS.ns);
    const webRoutingModulePath = getRoutingModulePath(utils_2.DEFAULT_SHARED_EXTENSIONS.web);
    let appTree;
    describe('when in ns-only project', () => {
        beforeEach(() => {
            appTree = test_utils_1.createEmptyNsOnlyProject(project);
        });
        let tree;
        describe('with default options', () => {
            beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
                tree = yield schematicRunner.runSchematicAsync('module', defaultOptions, appTree).toPromise();
            }));
            it('should create tns module file with no extension', () => {
                expect(tree.exists(noExtensionModulePath)).toBeTruthy();
                expect(test_1.getFileContent(tree, noExtensionModulePath)).toContain('NativeScriptCommonModule');
                expect(test_1.getFileContent(tree, noExtensionModulePath)).toContain(`class ${moduleClassName}`);
            });
            it('should not create files with .tns extension', () => {
                expect(tree.exists(nsModulePath)).toBeFalsy();
            });
            it('should not create a common file', () => {
                expect(tree.exists(commonFilePath)).toBeFalsy();
            });
            it('should not have CommonModule imported', () => {
                const content = test_1.getFileContent(tree, noExtensionModulePath);
                expect(content).not.toMatch(`import { CommonModule } from '@angular/common'`);
                expect(content).not.toMatch(test_utils_1.isInModuleMetadata(moduleClassName, 'imports', 'CommonModule', true));
            });
            it('should have NativeScriptCommonModule imported', () => {
                const content = test_1.getFileContent(tree, noExtensionModulePath);
                expect(content).toMatch(`import { NativeScriptCommonModule } from '@nativescript/angular'`);
            });
            it('should have NO_ERRORS_SCHEMA imported', () => {
                const content = test_1.getFileContent(tree, noExtensionModulePath);
                expect(content).toMatch(/import { [^}]*NO_ERRORS_SCHEMA(.*)} from '@angular\/core';/);
            });
            it('should have NO_ERRORS_SCHEMA declared', () => {
                const content = test_1.getFileContent(tree, noExtensionModulePath);
                expect(content).toMatch(test_utils_1.isInModuleMetadata(moduleClassName, 'schemas', 'NO_ERRORS_SCHEMA', true));
            });
        });
        it('should respect passed extension', () => __awaiter(void 0, void 0, void 0, function* () {
            const customExtension = '.mobile';
            const options = Object.assign(Object.assign({}, defaultOptions), { routing: true, nsExtension: customExtension });
            const testTree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
            const modulePath = getModulePath(customExtension);
            expect(testTree.exists(modulePath)).toBeTruthy();
            const routingModulePath = getRoutingModulePath(customExtension);
            expect(testTree.exists(routingModulePath)).toBeTruthy();
        }));
        it('should not have NativeScriptCommonModule imported if that is specified explicitly', () => __awaiter(void 0, void 0, void 0, function* () {
            const options = Object.assign(Object.assign({}, defaultOptions), { commonModule: false });
            const testTree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
            const content = test_1.getFileContent(testTree, noExtensionModulePath);
            expect(content).not.toMatch(`import { NativeScriptCommonModule } from '@nativescript/angular'`);
        }));
        it('should not have RouterModule imported in the routing module', () => __awaiter(void 0, void 0, void 0, function* () {
            const options = Object.assign(Object.assign({}, defaultOptions), { routing: true });
            const testTree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
            const content = test_1.getFileContent(testTree, noExtensionModulePath);
            expect(content).not.toMatch(`import { RouterModule } from '@angular/router'`);
            expect(content).not.toMatch(test_utils_1.isInModuleMetadata(moduleClassName, 'exports', 'RouterModule.forChild', true));
            expect(content).not.toMatch(test_utils_1.isInModuleMetadata(moduleClassName, 'exports', 'RouterModule', true));
        }));
        it('should have NativeScriptRouterModule imported', () => __awaiter(void 0, void 0, void 0, function* () {
            const options = Object.assign(Object.assign({}, defaultOptions), { routing: true });
            const testTree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
            const content = test_1.getFileContent(testTree, noExtensionRoutingModulePath);
            expect(content).toMatch(`import { NativeScriptRouterModule } from '@nativescript/angular'`);
        }));
    });
    describe('when in ns+web project', () => {
        beforeEach(() => {
            appTree = test_utils_1.createEmptySharedProject(project);
        });
        describe('executing ns-only schematic', () => {
            const nsOnlyOptions = Object.assign(Object.assign({}, defaultOptions), { nativescript: true, web: false });
            it('should create ns module file', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign({}, nsOnlyOptions);
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.files).toContain(nsModulePath);
                expect(test_1.getFileContent(tree, nsModulePath)).toContain('CommonModule');
                expect(test_1.getFileContent(tree, nsModulePath)).toContain(`class ${moduleClassName}`);
            }));
            it('should not create web module file', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign({}, nsOnlyOptions);
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.exists(webModulePath)).toBeFalsy();
            }));
            it('should not create a common file', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign({}, nsOnlyOptions);
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.exists(commonFilePath)).toBeFalsy();
            }));
            it('should respect passed extension', () => __awaiter(void 0, void 0, void 0, function* () {
                const customExtension = '.mobile';
                const options = Object.assign(Object.assign({}, nsOnlyOptions), { nsExtension: customExtension, routing: true });
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                const modulePath = getModulePath(customExtension);
                expect(tree.exists(modulePath)).toBeTruthy();
                const routingModulePath = getRoutingModulePath(customExtension);
                expect(tree.exists(routingModulePath)).toBeTruthy();
            }));
        });
        describe('executing web-only schematic', () => {
            const webOnlyOptions = Object.assign(Object.assign({}, defaultOptions), { nativescript: false, web: true });
            it('should create web module file', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign({}, webOnlyOptions);
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.files).toContain(webModulePath);
                expect(test_1.getFileContent(tree, webModulePath)).toContain('CommonModule');
                expect(test_1.getFileContent(tree, webModulePath)).toContain(`class ${moduleClassName}`);
            }));
            it('should not create ns module file', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign({}, webOnlyOptions);
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.exists(nsModulePath)).toBeFalsy();
            }));
            it('should not create a common file', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign({}, webOnlyOptions);
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.exists(commonFilePath)).toBeFalsy();
            }));
            it('should respect passed extension', () => __awaiter(void 0, void 0, void 0, function* () {
                const customExtension = '.web';
                const options = Object.assign(Object.assign({}, webOnlyOptions), { webExtension: customExtension, routing: true });
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                const modulePath = getModulePath(customExtension);
                expect(tree.exists(modulePath)).toBeTruthy();
                const routingModulePath = getRoutingModulePath(customExtension);
                expect(tree.exists(routingModulePath)).toBeTruthy();
            }));
        });
        describe('executing web+ns schematic', () => {
            const nsWebOptions = Object.assign(Object.assign({}, defaultOptions), { nativescript: true, web: true });
            it('should generate both web and ns module files', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign({}, nsWebOptions);
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.exists(nsModulePath)).toBeTruthy();
                expect(tree.exists(webModulePath)).toBeTruthy();
            }));
            it('should create a common file', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign({}, nsWebOptions);
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.exists(commonFilePath)).toBeTruthy();
            }));
            it('should create both routing modules when routing flag is passed', () => __awaiter(void 0, void 0, void 0, function* () {
                const options = Object.assign(Object.assign({}, nsWebOptions), { routing: true });
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                expect(tree.exists(nsRoutingModulePath)).toBeTruthy();
                expect(tree.exists(webRoutingModulePath)).toBeTruthy();
            }));
            it('should respect passed extension', () => __awaiter(void 0, void 0, void 0, function* () {
                const nsExtension = '.mobile';
                const webExtension = '.web';
                const options = Object.assign(Object.assign({}, nsWebOptions), { nsExtension, webExtension, routing: true });
                const tree = yield schematicRunner.runSchematicAsync('module', options, appTree).toPromise();
                const customWebModulePath = getModulePath(webExtension);
                const customNsModulePath = getModulePath(nsExtension);
                expect(tree.exists(customWebModulePath)).toBeTruthy();
                expect(tree.exists(customNsModulePath)).toBeTruthy();
                expect(tree.exists(customWebModulePath)).toBeTruthy();
                expect(tree.exists(customNsModulePath)).toBeTruthy();
                const customWebRoutingModulePath = getRoutingModulePath(webExtension);
                const customNsRoutingModulePath = getRoutingModulePath(nsExtension);
                expect(tree.exists(customWebRoutingModulePath)).toBeTruthy();
                expect(tree.exists(customNsRoutingModulePath)).toBeTruthy();
            }));
        });
    });
});
//# sourceMappingURL=index_spec.js.map