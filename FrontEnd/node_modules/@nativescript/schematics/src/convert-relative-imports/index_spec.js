"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const testing_1 = require("@angular-devkit/schematics/testing");
const test_1 = require("@schematics/angular/utility/test");
const test_utils_1 = require("../test-utils");
const sourceDirectory = 'src';
const importPrefix = '@src';
const defaultOptions = {
    project: 'my-app',
};
const projSetup = {
    projectName: defaultOptions.project,
    sourceDirectory,
    importPrefix,
};
const aboutModulePath = `${sourceDirectory}/about/about.module.ts`;
const relativeImportContent = `
  import { AboutComponent } from './about.component';
`;
const fixedImportContent = `
  import { AboutComponent } from '${importPrefix}/about/about.component';
`;
describe('Convert relative imports to mapped imports', () => {
    const schematicRunner = new testing_1.SchematicTestRunner('@nativescript/schematics', path_1.join(__dirname, '../collection.json'));
    it('should convert the relative imports in a newly generated file', () => __awaiter(void 0, void 0, void 0, function* () {
        let appTree = test_utils_1.createTestProject(projSetup);
        appTree.create(aboutModulePath, relativeImportContent);
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', defaultOptions, appTree).toPromise();
        const actual = test_1.getFileContent(appTree, aboutModulePath);
        expect(actual).toEqual(fixedImportContent);
    }));
    it('should convert the relative imports in a modified file', () => __awaiter(void 0, void 0, void 0, function* () {
        const existingContent = `
      import { AboutComponent } from '${importPrefix}/about/about.component';
    `;
        const modifiedContent = `
      import { AboutComponent } from '${importPrefix}/about/about.component';
      import { AboutComponent } from './other-about.component';
    `;
        const expected = `
      import { AboutComponent } from '${importPrefix}/about/about.component';
      import { AboutComponent } from '${importPrefix}/about/other-about.component';
    `;
        let appTree = test_utils_1.createTestProject(projSetup, [{
                path: aboutModulePath,
                content: existingContent,
            }]);
        appTree.overwrite(aboutModulePath, modifiedContent);
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', defaultOptions, appTree).toPromise();
        const actual = test_1.getFileContent(appTree, aboutModulePath);
        expect(actual).toEqual(expected);
    }));
    it('should convert the relative imports in a created and then renamed file', () => __awaiter(void 0, void 0, void 0, function* () {
        let appTree = test_utils_1.createTestProject(projSetup);
        const renamedFilePath = aboutModulePath.replace('.ts', '.tns.ts');
        appTree.create(aboutModulePath, relativeImportContent);
        appTree.rename(aboutModulePath, renamedFilePath);
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', defaultOptions, appTree).toPromise();
        const actual = test_1.getFileContent(appTree, renamedFilePath);
        expect(actual).toEqual(fixedImportContent);
    }));
    it('should not modify files that weren\'t modified', () => __awaiter(void 0, void 0, void 0, function* () {
        let appTree = test_utils_1.createTestProject(projSetup, [{
                path: aboutModulePath,
                content: relativeImportContent,
            }]);
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', defaultOptions, appTree).toPromise();
        const actual = test_1.getFileContent(appTree, aboutModulePath);
        expect(actual).toEqual(relativeImportContent);
    }));
    it('should not modify files with extension other than .ts', () => __awaiter(void 0, void 0, void 0, function* () {
        let appTree = test_utils_1.createTestProject(projSetup);
        const generatedFilePath = `${sourceDirectory}/about/about.component.tsx`;
        appTree.create(generatedFilePath, relativeImportContent);
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', defaultOptions, appTree).toPromise();
        const actual = test_1.getFileContent(appTree, generatedFilePath);
        expect(actual).toEqual(relativeImportContent);
    }));
    it('should not modify files specified as ignored in the invocation options', () => __awaiter(void 0, void 0, void 0, function* () {
        let appTree = test_utils_1.createTestProject(projSetup);
        appTree.create(aboutModulePath, relativeImportContent);
        const options = Object.assign(Object.assign({}, defaultOptions), { filesToIgnore: [aboutModulePath] });
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', options, appTree).toPromise();
        const actual = test_1.getFileContent(appTree, aboutModulePath);
        expect(actual).toEqual(relativeImportContent);
    }));
    it('should not modify files that are deleted by previous rules', () => __awaiter(void 0, void 0, void 0, function* () {
        let appTree = test_utils_1.createTestProject(projSetup, [{
                path: aboutModulePath,
                content: relativeImportContent,
            }]);
        appTree.delete(aboutModulePath);
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', defaultOptions, appTree).toPromise();
        expect(appTree.get(aboutModulePath)).toBeNull();
    }));
    it('should not modify files that were created and then deleted by previous rules', () => __awaiter(void 0, void 0, void 0, function* () {
        let appTree = test_utils_1.createTestProject(projSetup);
        appTree.create(aboutModulePath, relativeImportContent);
        appTree.delete(aboutModulePath);
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', defaultOptions, appTree).toPromise();
        expect(appTree.get(aboutModulePath)).toBeNull();
    }));
    it('should not modify files that were modified and then deleted by previous rules', () => __awaiter(void 0, void 0, void 0, function* () {
        let appTree = test_utils_1.createTestProject(projSetup, [{
                path: aboutModulePath,
                content: relativeImportContent,
            }]);
        appTree.overwrite(aboutModulePath, relativeImportContent + '\nconsole.log(\'modified\');\n');
        appTree.delete(aboutModulePath);
        appTree = yield schematicRunner.runSchematicAsync('convert-relative-imports', defaultOptions, appTree).toPromise();
        expect(appTree.get(aboutModulePath)).toBeNull();
    }));
});
//# sourceMappingURL=index_spec.js.map